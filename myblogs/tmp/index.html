<html>
<head>
	
	<title>tmp</title>
	<meta name="keywords" content="Acheron,blog,博客,代码,技术,书法,读书" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        
<script src="/js/util.js"></script>

        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"/>
    
    

<meta name="generator" content="Hexo 6.3.0"></head>

<body>


<h2 class="title">tmp</h2>

<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
<!-- 2098年3月10日 -->


<!--  -->
 </div>

</div>

<!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#sql"><span class="toc-text">sql:</span></a></li></ol> -->
<p>近年来，我的体重一直维持在108斤的线上，稳定的就像是贵党的基本方针，一百年不动摇。</p>
<p>我采用的方法是囚徒健身，不依靠任何器械，只需要利用自身体重</p>
<p>可以查看当前Java进程创建的活跃对象数目和占用内存大:jmap -histo:live 21386 | head -n 50<br>查看某程序(pid)运行时间：ps -p pid -o etime</p>
<p>在学习 Java GC 之前，我们需要记住一个单词：stop-the-world 。它会在任何一种 GC 算法中发生。stop-the-world 意味着 JVM 因为需要执行 GC 而停止了应用程序的执行。当 stop-the-world 发生时，除 GC 所需的线程外，所有的线程都进入等待状态，直到 GC 任务完成。GC 优化很多时候就是减少 stop-the-world 的发生。</p>
<p>新生代（Young generation）：绝大多数最新被创建的对象都会被分配到这里，由于大部分在创建后很快变得不可达，很多对象被创建在新生代，然后 “消失”。对象从这个区域“消失” 的过程我们称之为：Minor GC 。</p>
<p>老年代（Old generation）：对象没有变得不可达，并r从新生代周期中存活了下来，会被拷贝到这里。其区域分配的空间要比新生代多。也正由于其相对大的空间，发生在老年代的 GC 次数要比新生代少得多。对象从老年代中消失的过程，称之为：Major GC 或者 Full GC。</p>
<p>持久代（Permanent generation）也称之为 方法区（Method area）：用于保存类常量以及字符串常量。注意，这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生 GC。发生在这个区域的 GC 事件也被算为 Major GC 。只不过在这个区域发生 GC 的条件非常严苛，必须符合以下三种条件才会被回收：<br>1、所有实例被回收<br>2、加载该类的 ClassLoader 被回收<br>3、Class 对象无法通过任何途径访问（包括反射）<br>ung generation）、老年代（Old generation）所占空间比例为 1 : 2 。</p>
<p>新生代空间的构成与逻辑:<br>为了更好的理解 GC，我们来学习新生代的构成，它用来保存那些第一次被创建的对象，它被分成三个空间：<br>· 一个伊甸园空间（Eden）<br>· 两个幸存者空间（Fron Survivor、To Survivor）<br>默认新生代空间的分配：Eden : Fron : To &#x3D; 8 : 1 : 1</p>
<p>每个空间的执行顺序如下：<br>1、绝大多数刚刚被创建的对象会存放在伊甸园空间（Eden）。<br>2、在伊甸园空间执行第一次 GC（Minor GC）之后，存活的对象被移动到其中一个幸存者空间（Survivor）。<br>3、此后，每次伊甸园空间执行 GC 后，存活的对象会被堆积在同一个幸存者空间。<br>4、当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间。然后会清空已经饱和的哪个幸存者空间。<br>5、在以上步骤中重复 N 次（N &#x3D; MaxTenuringThreshold（年龄阀值设定，默认 15））依然存活的对象，就会被移动到老年代。</p>
<p>老年代空间的构成与逻辑:<br>老年代空间的构成其实很简单，它不像新生代空间那样划分为几个区域，它只有一个区域，里面存储的对象并不像新生代空间绝大部分都是朝闻道，夕死矣。这里的对象几乎都是从 Survivor 空间中熬过来的，它们绝不会轻易的狗带。因此，Full GC（Major GC）发生的次数不会有 Minor GC 那么频繁，并且做一次 Major GC 的时间比 Minor GC 要更长（约 10 倍）。</p>
<p><a href="https://dzone.com/articles/java-performance-tuning">https://dzone.com/articles/java-performance-tuning</a>:</p>
<p>Arrangement of generations:<br>The diagram below shows how objects get created in New generation and then move to survivor Spaces at every GC run, and if they survive for long to be considered old, they get moved to the Tenured generation. The number of times an object need to survive GC cycles to be considered old enough can be configured.<br><a href="https://static.dzone.com/dz1/dz-files/slide0022_image016.gif">vj</a><br>By default, Java has 2 separate  threads for GC, one each for young(minor GC) and old generation(major GC). The minor GC (smaller pause, but more frequent) occurs to clean up garbage in the young generation, while  the major GC (larger pause, but less frequent) cleans up the  garbage  in the old  generation. If the major GC too fails to free required memory, the JVM increases the current memory to help create new object. This whole  cycle  can go on till the current memory reaches the MaxMemory for the JVM (default is 64MB for client JVM), after which JVM throws OutOfMemory Error.</p>
<p>Permanent Generation<br>Class information is stored in the perm generation. Also constant strings are stored there. Strings created dynamically in your application with String.intern() will also be stored in the perm generation. </p>
<p>Java.lang.OutOfMemoryError can occur due to 3 possible reasons:</p>
<ol>
<li><p>JavaHeap space low to create new objects . Increase by -Xmx    (java.lang.OutOfMemoryError: Java heap space).<br>java.lang.OutOfMemoryError: Java heap space<br>MaxHeap&#x3D;30528 KB  TotalHeap&#x3D;30528 KB FreHeap&#x3D;170 KB  UsedHeap&#x3D;30357 KB</p>
</li>
<li><p>Permanent Generation low. Increase by XX:MaxPermSize&#x3D;256m (java.lang.OutOfMemoryError: PermGen space)<br>java.lang.OutOfMemoryError: PermGen space<br>MaxHeap&#x3D;65088 KB  TotalHeap&#x3D;17616 KB      FreeHeap&#x3D;9692 KB  UsedHeap&#x3D;7923 KBo</p>
</li>
<li><p>java.lang.OutOfMemoryError:  …. Out of swap space …<br>JNI Heap runs low on memory, even though the JavaHeap and the PermGen have memory. This typically happens if you are  meking lots of heavy JNI calls, but the JavaHeap objects occupy little space. In that scenario the GC might not feel the urge to cleanup JavaHeap, while the JNI Heap keeps on increasing till it goes out of memory.</p>
</li>
</ol>
<p>If you use java NIO packages, watch out for this issue. DirectBuffer allocation uses the native heap.</p>
<p>The NativeHeap can be increasded by -XX:MaxDirectMemorySize&#x3D;256M (default is 128)</p>
<p>从 JDK1.7 开始的 “去永久代” 化，终于在 JDK1.8 中，被彻底的执行了，永久代被彻底 removed，同时 HotSpot 新增了一块叫做 Mataspace 的区域，并提供了 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 参数，来设置运行 Java 虚拟机使用的 Metaspace 的初始容量和最大容量。</p>
<p>Client 模式和 Server 模式</p>
<p>这是 Java 的两种运行模式，顾名思义，一个用在客户端，一个用在服务器端。</p>
<p>Client 模式和 Server 模式不同点在于即时编译器的优化程度，当采用 Client 模式时，JVM 只启用一个叫 C1 的即时编译器（Client Complier）, 这个即时编译器会对指令进行一些简单、可靠的优化；而当采用 Server 模式时，则会再启用一个叫 C2 的重量级即时编译器（Server Complier），会进行一些比较耗时的优化，甚至会做一些不可靠的激进优化。</p>
<p>HotSpot 会根据自身版本和宿主机器的硬件性能自动选择运行模式，用户也可以使用 “-client” 或者 “-server” 来强制指定虚拟机运行在 client 模式或者 server 模式。</p>
<p>比如笔者在自己机器的命令行上直接敲入 “java -version”, 可以看到是在 serer 模式下运行，并且采用 mixed mode:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -client -version</span><br><span class="line">java version &quot;1.8.0_121&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_121-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)</span><br></pre></td></tr></table></figure>
















<h1 id="sql"><a href="#sql" class="headerlink" title="sql:"></a>sql:</h1><p>DISTINCT 分句<br>SELECT DISTINCT 语句用于返回不同的值。 DISTINCT 是一个分句，能不用尽量不用，因为如果将 DISTINCT 添加到查询语句中，会导致执行时间的增加 。</p>
<p>在可以使用UNION ALL的语句里，使用了UNION<br>UNION 因为会将各查询子集的记录做比较，故比起UNION ALL ，通常速度都会慢上许多。一般来说，如果使用UNION ALL能满足要求的话，务必使用UNION ALL。</p>


<!--<a href="http://ac-heron.github.io/myblogs/tmp/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>